ğŸ§® FIBONACCI NUMBERS â€“ THEORY NOTES
ğŸ”¹ Definition

The Fibonacci sequence is a series of numbers where each number is the sum of the two numbers before it.

ğŸ‘‰ Formula:

ğ¹
(
ğ‘›
)
=
ğ¹
(
ğ‘›
âˆ’
1
)
+
ğ¹
(
ğ‘›
âˆ’
2
)
F(n)=F(nâˆ’1)+F(nâˆ’2)

with

ğ¹
(
0
)
=
0
,
ğ¹
(
1
)
=
1
F(0)=0,F(1)=1
ğŸ”¹ Example Sequence
n	0	1	2	3	4	5	6	7	8	9
F(n)	0	1	1	2	3	5	8	13	21	34
ğŸ”¹ Purpose

Fibonacci numbers are widely used in:

Mathematics â€“ sequences and series problems

Computer Science â€“ recursion, dynamic programming, and algorithm design

Nature & Art â€“ spirals in shells, flowers, etc.

âš™ï¸ PROGRAM EXPLANATION
ğŸ§© 1. Recursive Method
ğŸ§  Logic:

Recursion means a function calling itself.

ğŸ§¾ Code:
def fib_recursive(n):
    if n <= 1:
        return n
    else:
        return fib_recursive(n - 1) + fib_recursive(n - 2)

ğŸ” Line-by-line Explanation:

if n <= 1:
â†’ For the first two numbers (0 and 1), directly return n.

else:
â†’ For all other numbers, call the same function for (n-1) and (n-2) and add them.

This keeps happening until base condition (n <= 1) is reached.

ğŸ“Š Example (dry run for n = 5):
fib(5)
= fib(4) + fib(3)
= (fib(3)+fib(2)) + (fib(2)+fib(1))
= ((fib(2)+fib(1)) + (fib(1)+fib(0))) + ((fib(1)+fib(0)) + 1)
= ...
= 5

âš¡ Output for n = 10:
0 1 1 2 3 5 8 13 21 34

âš™ï¸ Time Complexity:

O(2â¿) (very slow for large n because it repeats calculations)

Space Complexity: O(n) (due to recursive calls)

ğŸ§© 2. Non-Recursive (Iterative / Loop) Method
ğŸ§  Logic:

We calculate Fibonacci numbers using a loop, storing the last two numbers and updating them each time.

ğŸ§¾ Code:
def fib_non_recursive(n):
    a = 0
    b = 1
    for i in range(n):
        print(a, end=" ")
        c = a + b
        a = b
        b = c

ğŸ” Line-by-line Explanation:

a = 0, b = 1 â†’ starting values

for i in range(n): â†’ loop runs n times

print(a, end=" ") â†’ prints current Fibonacci number

c = a + b â†’ find next number

a = b â†’ shift a to next value

b = c â†’ shift b to next value

This continues until we print all Fibonacci numbers up to n terms.

âš¡ Output for n = 10:
0 1 1 2 3 5 8 13 21 34

âš™ï¸ Time Complexity:

O(n) (much faster)

Space Complexity: O(1) (no recursion, just variables)

ğŸ§¾ Final Output (Full Program)
Recursive Fibonacci:
0 1 1 2 3 5 8 13 21 34
Non-Recursive Fibonacci:
0 1 1 2 3 5 8 13 21 34

ğŸ” Difference Between Recursive and Non-Recursive
Feature	Recursive	Non-Recursive
Approach	Function calls itself	Uses a loop
Speed	Slow (repeats work)	Fast
Memory Use	More (stack calls)	Less
Complexity	O(2â¿)	O(n)
Simplicity	Conceptually simple	Logically simple
ğŸ§  Key Points to Remember

Fibonacci follows: F(n) = F(nâˆ’1) + F(nâˆ’2)

Base cases: F(0) = 0, F(1) = 1

Recursion is elegant but inefficient.

Iteration is faster and uses less memory.

Would you like me to give you a handwritten-style short summary note (for exam or viva) â€” like â€œdefinition + logic + dry run + output in one pageâ€?
