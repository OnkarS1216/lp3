üß† Problem Statement ‚Äî What are we doing?
We have a set of characters and their frequencies (how often each appears).
We need to generate Huffman Codes ‚Äî shorter binary codes for frequent characters and longer ones for rare characters, to compress data efficiently.
Example input:
Characters: a, b, c, d, e, f
Frequencies: 5, 9, 12, 13, 16, 45


üìò Step-by-Step Code Explanation

```python
import heapq
‚úÖ **Imports the heapq library** ‚Äî  
This gives us a **min-heap** (priority queue), where the smallest item is always at the top.

We‚Äôll use it to always pick **two smallest frequencies** when building the Huffman Tree.

---

### ```python
class Node:

We create a Node class to represent each node in the tree (each character and its frequency).

```python
def init(self, char, freq):
self.char = char
self.freq = freq
self.left = self.right = None
Each node stores:
- `char` ‚Üí character (like `'a'`)
- `freq` ‚Üí frequency (like `5`)
- `left` and `right` ‚Üí pointers to child nodes (used to connect the tree)

---

### ```python
def __lt__(self, other): return self.freq < other.freq

This tells Python how to compare nodes (by frequency).
So, when using heapq, it knows which node is smaller.
Example:
Node('a',5) < Node('b',9) ‚Üí True


üß© Function 1: huffman_encoding(chars, freqs)
```python
heap = [Node(c, f) for c, f in zip(chars, freqs)]
This line does 3 things:
1. `zip(chars, freqs)` joins character and frequency together:

[('a',5), ('b',9), ('c',12), ('d',13), ('e',16), ('f',45)]
2. For each pair, creates a Node ‚Üí `[Node('a',5), Node('b',9), ...]`
3. Stores them in a list called `heap`.

---

### ```python
heapq.heapify(heap)

Turns the list into a min-heap based on frequency.
Now smallest frequency (like 5) is always on top.

```python
while len(heap) > 1:
We repeat until only **one node** (the root) is left ‚Äî that‚Äôs our final Huffman Tree.

---

### ```python
left, right = heapq.heappop(heap), heapq.heappop(heap)



Removes the two smallest nodes from the heap.


These are combined into a new node.


Example (first step):
Remove 'a'(5) and 'b'(9)


```python
merged = Node(None, left.freq + right.freq)
- Creates a **new node** with no character (`None`)
- Its frequency = sum of the two merged nodes.

Example:

New node freq = 5 + 9 = 14

---

### ```python
merged.left, merged.right = left, right

Connects the two smallest nodes as children of the new merged node.
Example:
    (14)
   /    \
 (5)    (9)


```python
heapq.heappush(heap, merged)
Adds the merged node back into the heap.

Now, the heap again sorts nodes by frequency.

---

### ```python
return heap[0]

After the loop ends, only one node remains ‚Üí the root of the Huffman tree.
We return it.

üß© Function 2: print_codes(node, code="")
This function prints the Huffman codes for each character.

```python
if node is None: return
Stops if there‚Äôs no node (base case).

---

### ```python
if node.char: print(f"{node.char}: {code}")

If the node has a character (i.e., a leaf node), print its code.
Example output:
a: 1100
b: 1101
...


```python
print_codes(node.left, code + "0")
print_codes(node.right, code + "1")
We go left and right recursively.

- Left path ‚Üí add `"0"`
- Right path ‚Üí add `"1"`

So codes are formed by the path from root to leaf.

---

## üèÅ Main Program

```python
if __name__ == "__main__":

This means: run the below code only when this file is directly executed.

```python
chars = ['a','b','c','d','e','f']
freqs = [5,9,12,13,16,45]
Our input data (characters and their frequencies).

---

### ```python
root = huffman_encoding(chars, freqs)

This builds the Huffman Tree and returns the root node.

```python
print("characters:", chars)
print("frequencies:", freqs)
print("Huffman Codes:")
print_codes(root)
Finally, it prints each character with its Huffman code.

---

## üìä Dry Run (short version)

| Step | Action | Heap State (frequencies) |
|------|---------|--------------------------|
| 1 | Take 5,9 ‚Üí merge = 14 | [12,13,14,16,45] |
| 2 | Take 12,13 ‚Üí merge = 25 | [14,16,25,45] |
| 3 | Take 14,16 ‚Üí merge = 30 | [25,30,45] |
| 4 | Take 25,30 ‚Üí merge = 55 | [45,55] |
| 5 | Take 45,55 ‚Üí merge = 100 | [100] |

‚úÖ Final root = 100  
‚úÖ Tree built successfully  
‚úÖ Then we traverse to print Huffman codes.

---

## üßæ Example Output:

characters: ['a', 'b', 'c', 'd', 'e', 'f']
frequencies: [5, 9, 12, 13, 16, 45]
Huffman Codes:
f: 0
c: 100
d: 101
a: 1100
b: 1101
e: 111

---

Would you like me to draw the **final Huffman tree (in text format)** showing left(0)/right(1) clearly? It will help you visualize where each code comes from.




üß† Problem: What Are We Doing?

We have some characters (like 'a', 'b', 'c', etc.)
Each has a frequency (how many times it appears).
We want to build a Huffman Tree that gives short binary codes (0/1) for frequent letters and longer ones for less frequent letters.
üëâ This helps compress data.

üîπ FULL CODE EXPLAINED ‚Äî LINE BY LINE
```python

import heapq

- `import` ‚Üí tells Python to bring an **external library**.  
- `heapq` ‚Üí is a built-in Python module that lets us use a **min-heap (priority queue)**.  
  - A heap is a data structure where the **smallest element** is always at the top.  
  - We‚Äôll use this to easily pick the **two smallest frequency nodes** each time.

---

### ```python
class Node:


class ‚Üí is used to create your own data type (a blueprint for objects).

Node ‚Üí is the name of the class.
This class will represent one node of the Huffman tree (it can hold a character and its frequency).

```python
def __init__(self, char, freq):

- `def` ‚Üí defines a function.  
- `__init__` ‚Üí is a **special method** that runs **automatically** whenever you create a new `Node`.  
- `self` ‚Üí refers to the **current object** being created.  
- `char` ‚Üí a parameter to store the **character** (like `'a'`).  
- `freq` ‚Üí a parameter to store the **frequency** (like `5`).

So when you write:
```python
Node('a', 5)


It means:

Create a node that represents the letter 'a' with frequency 5.

```python
    self.char = char

- `self.char` ‚Üí is a **variable inside the object**.  
- `=` ‚Üí assigns value.  
- `char` ‚Üí the input parameter.  
So this line means:
> Store the character value inside the node.

---

### ```python
        self.freq = freq


Same idea:

Store the frequency value inside the node.

So now the node knows:
character = 'a', frequency = 5

```python
    self.left = self.right = None

We‚Äôre creating two **links (pointers)** for the tree:
- `left` ‚Üí will store the left child node.
- `right` ‚Üí will store the right child node.
- `None` ‚Üí means currently there‚Äôs no child (it‚Äôs empty).

Later we will connect them when merging nodes.

---

### ```python
    def __lt__(self, other): return self.freq < other.freq


This is a special comparison function used when the heap (heapq) compares two Nodes.

__lt__ means ‚Äúless than‚Äù (<).

self ‚Üí current node being compared.

other ‚Üí another node.

self.freq < other.freq ‚Üí compares based on their frequencies.

So this line tells Python:

When comparing two Node objects, compare their frequencies.

Example:

Node('a', 5) < Node('b', 9)  # True because 5 < 9

‚öôÔ∏è Function 1 ‚Äî Building the Huffman Tree
```python

def huffman_encoding(chars, freqs):

We‚Äôre defining a new function called `huffman_encoding`  
It takes two lists:
- `chars` ‚Üí list of characters like `['a','b','c','d','e','f']`
- `freqs` ‚Üí list of frequencies like `[5,9,12,13,16,45]`

---

### ```python
    heap = [Node(c, f) for c, f in zip(chars, freqs)]


Let‚Äôs break it down:

zip(chars, freqs) ‚Üí pairs characters with their frequencies:

[('a',5), ('b',9), ('c',12), ('d',13), ('e',16), ('f',45)]


for c, f in zip(chars, freqs) ‚Üí loops through each (character, frequency) pair.

Node(c, f) ‚Üí creates a Node object for each pair.

[ ... ] ‚Üí creates a list.

So heap will now contain:

[Node('a',5), Node('b',9), Node('c',12), Node('d',13), Node('e',16), Node('f',45)]

```python
heapq.heapify(heap)

This converts the list into a **min-heap** automatically.

Now the smallest frequency node (5) will be at the top.  
Heap helps us always pick the **two smallest** nodes efficiently.

---

### ```python
    while len(heap) > 1:


While there‚Äôs more than one node in the heap,
‚Üí We‚Äôll keep merging nodes until only one (the root) remains.

```python
    left, right = heapq.heappop(heap), heapq.heappop(heap)

- `heapq.heappop(heap)` ‚Üí removes and returns the **smallest node** from the heap.  
- We pop **two smallest** nodes at a time ‚Äî they will become children of a new parent node.

Example (first step):


Pop (a,5) and (b,9)


---

### ```python
        merged = Node(None, left.freq + right.freq)


We create a new merged node:

char=None ‚Üí because this new node doesn‚Äôt represent a single character.

freq = left.freq + right.freq ‚Üí total frequency of both children.

Example:

5 + 9 = 14
So merged node = (None, 14)

```python
    merged.left, merged.right = left, right

We attach the two smallest nodes as children:
- `left` ‚Üí left child
- `right` ‚Üí right child

So the structure becomes:

   (14)
  /    \


(5) (9)


---

### ```python
        heapq.heappush(heap, merged)


We push the merged node back into the heap.
Now the heap again sorts automatically by frequency.

```python
return heap[0]

When the loop ends, only **one node** is left ‚Üí the root of the Huffman Tree.  
We return it.

---

## ‚öôÔ∏è Function 2 ‚Äî Printing the Codes

### ```python
def print_codes(node, code=""):


This function prints Huffman codes for all characters.

node ‚Üí current node (starting from root)

code ‚Üí the binary code built so far (starts empty)

```python
if node is None: return

If there‚Äôs no node (empty), just stop ‚Äî base case for recursion.

---

### ```python
    if node.char: print(f"{node.char}: {code}")


If the node has a character (i.e., it‚Äôs a leaf node),
print the character and its code.

Example:

a: 1100
b: 1101

```python
print_codes(node.left, code + "0")
print_codes(node.right, code + "1")

Recursive calls:
- Go **left** ‚Üí add `"0"` to the code.
- Go **right** ‚Üí add `"1"` to the code.

So as we go down the tree, the code builds up.

---

## üèÅ MAIN PROGRAM

### ```python
if __name__ == "__main__":


This line ensures the below code runs only when you directly execute this file, not when it‚Äôs imported elsewhere.

```python
chars = ['a','b','c','d','e','f']

List of **characters**.

---

### ```python
    freqs = [5,9,12,13,16,45]


List of their frequencies.

```python
root = huffman_encoding(chars, freqs)

This calls the function we made ‚Üí builds the Huffman tree ‚Üí returns the **root node**.

---

### ```python
    print("characters:", chars)
    print("frequencies:", freqs)


Just displays the input lists for clarity.

```python
print("Huffman Codes:")

Prints a heading before showing the codes.

---

### ```python
    print_codes(root)


Calls our recursive function to print each character and its Huffman binary code.

‚úÖ Example Output
characters: ['a', 'b', 'c', 'd', 'e', 'f']
frequencies: [5, 9, 12, 13, 16, 45]
Huffman Codes:
f: 0
c: 100
d: 101
a: 1100
b: 1101
e: 111
